<!DOCTYPE html>

<html>

<head>
<style>
    body {
        /* set margin to 0 and overflow to hidden, to go fullscreen */
        margin: 0;
        overflow: hidden;
        background-color: #000000;
    }
</style>

<title>Physijs Constraints</title>

<script type="text/javascript" src="three.js"></script>
<script type="text/javascript" src="stats.js"></script>
<script type="text/javascript" src="physi.js"></script>
<script type="text/javascript" src="dat.gui.js"></script>
<script type="text/javascript" src="chroma.js"></script>
<script type="text/javascript" src="TrackballControls.js"></script>
<script type="text/javascript" src="perlin.js"></script>
<script type="text/javascript" src="OrbitControls.js"></script>
<script type="text/javascript" src="RollControls.js"></script>

<script type="text/javascript">

'use strict';

Physijs.scripts.worker = 'physijs_worker.js';
Physijs.scripts.ammo = 'ammo.js';

var scale = chroma.scale(['white', 'blue', 'red', 'yellow','green']);
var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;

var initScene, render, applyForce, setMousePosition, mouse_position,
        ground_material, box_material,velocity ,wheelAngle , car, mouseX,mouseY,
        clock,orbitControls,delta,rollControls,
        projector, renderer, render_stats, physics_stats, scene, ground, light, camera, box, boxes = [];

initScene = function () {
    projector = new THREE.Projector;

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);

    renderer.setClearColorHex(0x000000);
    renderer.shadowMapEnabled = true;


    document.getElementById('viewport').appendChild(renderer.domElement);

    render_stats = new Stats();
    render_stats.domElement.style.position = 'absolute';
    render_stats.domElement.style.top = '1px';
    render_stats.domElement.style.left = '1px';
    render_stats.domElement.style.zIndex = 100;
    document.getElementById('viewport').appendChild(render_stats.domElement);


    scene = new Physijs.Scene({reportSize: 10, fixedTimeStep: 1 / 60});

    scene.setGravity(new THREE.Vector3(0, -40, 0));

    camera = new THREE.PerspectiveCamera(
            35,
            window.innerWidth / window.innerHeight,
            1,
            1000
    );
    camera.position.set(190, 190, 190);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    scene.add(camera);

    // Light
    light = new THREE.DirectionalLight(0xFFFFFF);
    light.position.set(1200, 700, 1000);
    light.castShadow = true;
    light.shadowMapDebug = true;
    light.shadowCameraNear = 10;
    light.shadowCameraFar = 200;


    scene.add(light);


    var meshes = [];


    createGround();
    createCube();
    //var car = createCar();
    car = createCar();

    velocity = -2;
    wheelAngle = 0.3;

    //控制鼠标视觉角度
/*    clock = new THREE.Clock();
    rollControls = new THREE.RollControls(camera);
    rollControls.movementSpeed = 0;
    rollControls.lookSpeed = 1;*/

    //camera.lookAt(car.position.x,car.position.y,car.position.z);

    var ua=false,us=false,ud=false,uw=false,uspace=false;
    //var mouseX,mouseY;
    document.addEventListener("keydown", onKeyDown, false);
    document.addEventListener("keyup", onKeyUp, false);
    //document.addEventListener( 'mousemove', onDocumentMouseMove, false );

    function onKeyDown(a){
        var b = a.keyCode;
        if ((b == 38 || b == 87) && velocity > -10 && velocity<= 10){
            uw = true;
            option();
        }
        else if ((b == 40 || b == 83) && velocity >= -10 && velocity< 10){
            us = true;
            option();
        }
        else if ((b == 37 || b == 65) && wheelAngle >= -0.6 && wheelAngle < 0.6){
            ua = true;
            option();
        }
        else if ((b == 39 || b  == 68) && wheelAngle > -0.6 && wheelAngle <= 0.6){
            ud = true;
            option();
        }
        else if (b == 32){
            uspace = true;
            option();
        }
        
    }

    function onKeyUp(a){
        var b = a.keyCode;
        if (b == 38 || b == 87)
            uw = false;
        else if (b == 40 || b == 83)
            us = false;
        else if (b == 37 || b == 65)
            ua = false;
        else if (b == 39 || b == 68)
            ud = false;
        else if (b == 32)
            uspace = false;
    }

    function option(){
        if(uw == true )
            velocity += -0.5;
        if(us == true)
            velocity += 0.5;
        if(ua == true)
            wheelAngle += 0.1;
        if(ud == true)
            wheelAngle += -0.1;
        if(uspace == true)
            velocity = 0;

        car.flConstraint.configureAngularMotor(2, 0.1, 0, velocity, 15000);
        car.frConstraint.configureAngularMotor(2, 0.1, 0, velocity, 15000);

        car.rrConstraint.setAngularLowerLimit({ x: 0, y: wheelAngle, z: 0.1 });
        car.rrConstraint.setAngularUpperLimit({ x: 0, y: wheelAngle, z: 0 });
        car.rlConstraint.setAngularLowerLimit({ x: 0, y: wheelAngle, z: 0.1 });
        car.rlConstraint.setAngularUpperLimit({ x: 0, y: wheelAngle, z: 0 });
        car.flConstraint.enableAngularMotor(2);
        car.frConstraint.enableAngularMotor(2);

    }

/*    
    function onDocumentMouseMove( event ) {

        mouseX = ( event.clientX - windowHalfX ) * 0.1;
        mouseY = -( event.clientY - windowHalfY ) * 0.1;

        if(mouseX > 0){
            if(camera.rotation.x < 0){
                camera.rotation.x = 0;
            }
            camera.rotation.x += 0.01;
        }
        else if(mouseX < 0){
            if(mouseX > 0){
                camera.position.x = 0;
            }
            camera.position.x -= 0.01;
        }
        //camera.position.x += ( mouseX - camera.position.x ) * .05;
        //camera.position.y += ( - mouseY - camera.position.y ) * .05;
        //camera.lookAt.x+= ( mouseX - camera.position.x ) * .05;
        //camera.lookAt.y += ( - mouseY - camera.position.y ) * .05;
        //requestAnimationFrame(render);
    }
*/

/*    //orbitControls
    clock = new THREE.Clock();
    orbitControls = new THREE.OrbitControls(camera);
    orbitControls.autoRotate = false;
    delta = clock.getDelta();
    orbitControls.update(delta);
*/
    requestAnimationFrame(render);
    scene.simulate();

    
};



function createWheel(position) {
    var wheel_material = Physijs.createMaterial(
            new THREE.MeshLambertMaterial({ color: 0x444444, opacity: 0.9, transparent: true }),
            1.0, // high friction
            .5 // medium restitution
    );

    var wheel_geometry = new THREE.CylinderGeometry(4, 4, 2, 10);
    var wheel = new Physijs.CylinderMesh(
            wheel_geometry,
            wheel_material,
            100
    );

    wheel.rotation.x = Math.PI / 2;
    wheel.castShadow = true;
    wheel.position = position;
    return wheel;
}


function createCar() {
    var car = {};
    var car_material = Physijs.createMaterial(
            new THREE.MeshLambertMaterial({ color: 0xff4444, opacity: 0.9, transparent: true }),
            .5, // high friction
            .5 // medium restitution
    );

    // create the car body
    var geom = new THREE.CubeGeometry(15, 4, 4);
    var body = new Physijs.BoxMesh(geom, car_material, 500);
    body.position.set(5, 5, 5);
    car.position = body.position;
    body.castShadow = true;
    scene.add(body);

    // create the wheels
    var fr = createWheel(new THREE.Vector3(0, 4, 10));
    var fl = createWheel(new THREE.Vector3(0, 4, 0));
    var rr = createWheel(new THREE.Vector3(10, 4, 10));
    var rl = createWheel(new THREE.Vector3(10, 4, 0));

    // add the wheels to the scene
    scene.add(fr);
    scene.add(fl);
    scene.add(rr);
    scene.add(rl);

    var frConstraint = createWheelConstraint(fr, body, new THREE.Vector3(0, 4, 8));
    scene.addConstraint(frConstraint);

    var flConstraint = createWheelConstraint(fl, body, new THREE.Vector3(0, 4, 2));
    scene.addConstraint(flConstraint);

    var rrConstraint = createWheelConstraint(rr, body, new THREE.Vector3(10, 4, 8));
    scene.addConstraint(rrConstraint);

    var rlConstraint = createWheelConstraint(rl, body, new THREE.Vector3(10, 4, 2));
    scene.addConstraint(rlConstraint);


    // backwheels don't move themselves and are restriced in their
    // movement. They should be able to rotate along the z-axis
    // same here, if the complete angle is allowed set lower higher
    // than upper.
    // by setting the lower and upper to the same value you can
    // fix the position
    // we can set the x position to 'loosen' the axis for the directional
    rrConstraint.setAngularLowerLimit({ x: 0, y: 0.3, z: 0.1 });//0.5
    rrConstraint.setAngularUpperLimit({ x: 0, y: 0.3, z: 0 });
    rlConstraint.setAngularLowerLimit({ x: 0, y: 0.3, z: 0.1 });
    rlConstraint.setAngularUpperLimit({ x: 0, y: 0.3, z: 0 });


    // front wheels should only move along the z axis.
    // we don't need to specify anything here, since
    // that value is overridden by the motors
    frConstraint.setAngularLowerLimit({ x: 0, y: 0, z: 0 });
    frConstraint.setAngularUpperLimit({ x: 0, y: 0, z: 0 });
    flConstraint.setAngularLowerLimit({ x: 0, y: 0, z: 0 });
    flConstraint.setAngularUpperLimit({ x: 0, y: 0, z: 0 });

    // if you add a motor, the current constraint is overridden
    // if you want to rotate set min higher then max
    flConstraint.configureAngularMotor(2, 0.1, 0, -2, 1500);//-2
    frConstraint.configureAngularMotor(2, 0.1, 0, -2, 1500);

    // motor one is for left and right
//                frConstraint.enableAngularMotor(1);

    // motor two is forward and backwards
    flConstraint.enableAngularMotor(2);
    frConstraint.enableAngularMotor(2);

    car.flConstraint = flConstraint;
    car.frConstraint = frConstraint;
    car.rlConstraint = rlConstraint;
    car.rrConstraint = rrConstraint;

    return car;
}

function createWheelConstraint(wheel, body, position) {
    var constraint = new Physijs.DOFConstraint(
            wheel, body, position);

    return constraint;
}

function createGround() {
    var length = 1200;
    var width = 1200;
    // Materials
    ground_material = Physijs.createMaterial(
            new THREE.MeshPhongMaterial(
                    {
//                                color: 0xaaaaaa,
                        map: THREE.ImageUtils.loadTexture('floor-wood.jpg')
                    }),
            1, // high friction
            .7 // low restitution
    );

    // Ground
    ground = new Physijs.BoxMesh(
            new THREE.CubeGeometry(length, 1, width),
            ground_material,
            0 // mass
    );

    ground.receiveShadow = true;


    var borderLeft = new Physijs.BoxMesh(
            new THREE.CubeGeometry(2, 6, width),
            ground_material,
            0 // mass
    );

    borderLeft.position.x = -1 * length / 2 - 1;
    borderLeft.position.y = 2;
    borderLeft.receiveShadow = true;


    ground.add(borderLeft);

    var borderRight = new Physijs.BoxMesh(new THREE.CubeGeometry(2, 6, width),
            ground_material,
            0 // mass
    );
    borderRight.position.x = length / 2 + 1;
    borderRight.position.y = 2;
    borderRight.receiveShadow = true;

    ground.add(borderRight);


    var borderBottom = new Physijs.BoxMesh(
            new THREE.CubeGeometry(width - 1, 6, 2),
            ground_material,
            0 // mass
    );

    borderBottom.position.z = width / 2;
    borderBottom.position.y = 1.5;
    borderBottom.receiveShadow = true;
    ground.add(borderBottom);

    var borderTop = new Physijs.BoxMesh(
            new THREE.CubeGeometry(width, 6, 2),
            ground_material,
            0 // mass
    );

    borderTop.position.z = -width / 2;
    borderTop.position.y = 2;

    borderTop.receiveShadow = true;

    ground.position.x = 20;
    ground.position.z = -20;
    ground.add(borderTop);

    ground.receiveShadow = true;

    scene.add(ground);

    //起伏地面
    var date = new Date();
    var pn = new Perlin('rnd' + date.getTime());
    var map = createHeightMap(pn);
    scene.add(map);

    function createHeightMap(pn) {

        var ground_material = Physijs.createMaterial(
                new THREE.MeshLambertMaterial(
                        {
                            map: THREE.ImageUtils.loadTexture('grasslight-big.jpg')
                        }),
                .3, // high friction
                .8 // low restitution
        );

        var ground_geometry = new THREE.PlaneGeometry(320, 300, 100, 100);
        for (var i = 0; i < ground_geometry.vertices.length; i++) {
            var vertex = ground_geometry.vertices[i];
            var value = pn.noise(vertex.x / 30, vertex.y / 30, 0);
            vertex.z = value * 10;
        }
        ground_geometry.computeFaceNormals();
        ground_geometry.computeVertexNormals();

        var ground = new Physijs.HeightfieldMesh(
                ground_geometry,
                ground_material,
                0, // mass
                100,
                100
        );
        ground.position.set(200,-3,200);
        ground.rotation.x = Math.PI / -2;
        ground.rotation.y = 0;
        ground.receiveShadow = true;

        return ground;
    }
}

function createCube(){
    //var cubeSize = Math.ceil((Math.random() * 10));
    //var geometry = new THREE.CubeGeometry( cubeSize, cubeSize, cubeSize );
    var geometry = new THREE.CubeGeometry( 6, 6, 6 );
    //var material_cube = Physijs.createMaterial(new THREE.MeshLambertMaterial( { color: scale(Math.random()).hex(),} ),0.3,0);
    var cube = [];
    var i =0;
    for (; i <= 8; i++) {
        cube[i] = getCube(i);
        scene.add(cube[i]);
    };
    function getCube(){
        var material_cube = Physijs.createMaterial(new THREE.MeshLambertMaterial( { color: scale(Math.random()).hex(),} ),0.3,0);
        cube[i] = new Physijs.BoxMesh(geometry, material_cube);
        //cube[i].rotation.set(0,0,0); 
        var vx = i % 3;
        var vy = i / 3;
        cube[i].position.set(35+6*vx,4+6*vy,35);   
        cube[i].__dirtyRotation = true;
        return cube[i];
    }
     ;

    

}


render = function () {
    //控制camera跟踪车走
    //camera.position.set(car.position.x +100+mouseX,car.position.y+100+mouseY,car.position.z+100);
    camera.position.set(car.position.x +50,car.position.y+90,car.position.z+10);
    camera.lookAt(car.position);
    //控制鼠标视觉角度
/*    delta = clock.getDelta();
    rollControls.update(delta);*/
    
    requestAnimationFrame(render);
    renderer.render(scene, camera);
    render_stats.update();
    scene.simulate(undefined, 2);
};


window.onload = initScene;

</script>
</head>

<body>
<div id="viewport"></div>
</body>

</html>
